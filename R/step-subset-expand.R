#' Expand data frame to include all possible combinations of values.
#'
#' @description
#' This is a method for the tidyr `expand()` generic. It is translated to
#' [data.table::CJ()].
#'
#' @param data A [lazy_dt()].
#' @inheritParams tidyr::expand
#' @examples
#' library(tidyr)
#'
#' fruits <- lazy_dt(tibble(
#'   type   = c("apple", "orange", "apple", "orange", "orange", "orange"),
#'   year   = c(2010, 2010, 2012, 2010, 2010, 2012),
#'   size  =  factor(
#'     c("XS", "S",  "M", "S", "S", "M"),
#'     levels = c("XS", "S", "M", "L")
#'   ),
#'   weights = rnorm(6, as.numeric(size) + 2)
#' ))
#'
#' # All possible combinations ---------------------------------------
#' # Note that all defined, but not necessarily present, levels of the
#' # factor variable `size` are retained.
#' fruits %>% expand(type)
#' fruits %>% expand(type, size)
#' fruits %>% expand(type, size, year)
#'
#' # Other uses -------------------------------------------------------
#' fruits %>% expand(type, size, 2010:2012)
#'
#' # Use `anti_join()` to determine which observations are missing
#' all <- fruits %>% expand(type, size, year)
#' all
#' all %>% dplyr::anti_join(fruits)
#'
#' # Use with `right_join()` to fill in missing rows
#' fruits %>% dplyr::right_join(all)
# exported onLoad
expand.dtplyr_step <- function(data, ..., .name_repair = "check_unique") {
  dots <- capture_dots(data, ..., .j = FALSE)
  dots <- dots[!vapply(dots, is_null, logical(1))]
  if (length(dots) == 0) {
    return(data)
  }

  named_dots <- have_name(dots)
  symbol_dots <- vapply(dots, is_symbol, logical(1))
  if (any(!named_dots)) {
    # Auto-names generated by enquos() don't always work with the CJ() step
      ## Ex: `1:3`
    # Replicates the "V" naming convention data.table uses
    needs_v_name <- !symbol_dots & !named_dots
    v_names <- paste0("V", 1:length(dots))
    names(dots)[needs_v_name] <- v_names[needs_v_name]
    names(dots)[symbol_dots] <- lapply(dots[symbol_dots], as_name)
  }
  names(dots) <- vctrs::vec_as_names(names(dots), repair = .name_repair)

  # if group vars are supplied and not redefined, they don't need to be in CJ
  unnamed_symbols <- symbol_dots & !named_dots
  expand_cols <- dots[!(unnamed_symbols & names(dots) %in% data$groups)]
  names_expand <- names(expand_cols)

  out <- step_subset_j(
    data, j = expr(CJ(!!!expand_cols, unique = TRUE)), 
    vars = c(data$groups, names_expand)
  )

  # If group vars are redefined in expand, delete the old column
  if (any(names(expand_cols) %in% out$groups)) {
    group_vars <- out$groups
    redefined_group_vars <- names_expand[names_expand %in% group_vars]

    out <- step_subset(
      out, j = expr(!!redefined_group_vars := NULL), groups = character()
    )
    out <- group_by(out, !!!syms(group_vars))
  }

  out
}

# exported onLoad
expand.data.table <- function(data, ..., .name_repair = "check_unique") {
  data <- lazy_dt(data)
  tidyr::expand(data, ..., .name_repair = .name_repair)
}
