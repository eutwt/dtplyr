#' Expand data frame to include all possible combinations of values.
#'
#' @description
#' This is a method for the tidyr `expand()` generic. It is translated to
#' [data.table::CJ()]. Unlike the data.frame method, this method only retains
#' factor levels present in the data.
#'
#' @param data A [lazy_dt()].
#' @inheritParams tidyr::expand
#' @examples
#' library(tidyr)
#'
#' fruits <- lazy_dt(tibble(
#'   type   = c("apple", "orange", "apple", "orange", "orange", "orange"),
#'   year   = c(2010, 2010, 2012, 2010, 2010, 2012),
#'   size  =  factor(
#'     c("XS", "S",  "M", "S", "S", "M"),
#'     levels = c("XS", "S", "M", "L")
#'   ),
#'   weights = rnorm(6, as.numeric(size) + 2)
#' ))
#'
#' # Factors ----------------------------------------------------------
#' # When called on `fruits` defined above, the level "L" is not present in
#' # the output of `expand(fruits, size)`, unlike the output of `expand()` when
#' # `fruits` is a data.frame.
#'
#' fruits %>% expand(size) %>% as_tibble()
#' #> # A tibble: 3 × 1
#' #>   size
#' #>   <fct>
#' #> 1 XS
#' #> 2 S
#' #> 3 M
#' fruits %>% as_tibble() %>% expand(size)
#' #> # A tibble: 4 × 1
#' #>   size
#' #>   <fct>
#' #> 1 XS
#' #> 2 S
#' #> 3 M
#' #> 4 L
#'
#' # Other uses -------------------------------------------------------
#' fruits %>% expand(type, size, 2010:2012)
#'
#' # Use `anti_join()` to determine which observations are missing
#' all <- fruits %>% expand(type, size, year)
#' all
#' all %>% dplyr::anti_join(fruits)
#'
#' # Use with `right_join()` to fill in missing rows
#' fruits %>% dplyr::right_join(all)
# exported onLoad
expand.dtplyr_step <- function(data, ..., .name_repair = "check_unique") {
  dots <- capture_dots(data, ..., .j = FALSE)
  dots <- dots[!vapply(dots, is_null, logical(1))]
  if (length(dots) == 0) {
    return(data)
  }

  named_dots <- have_name(dots)
  if (any(!named_dots)) {
    # Auto-names generated by enquos() don't always work with the CJ() step
      ## Ex: `1:3`
    # Replicates the "V" naming convention data.table uses
    symbol_dots <- vapply(dots, is_symbol, logical(1))
    needs_v_name <- !symbol_dots & !named_dots
    v_names <- paste0("V", 1:length(dots))
    names(dots)[needs_v_name] <- v_names[needs_v_name]
    names(dots)[symbol_dots] <- lapply(dots[symbol_dots], as_name)
  }
  names(dots) <- vctrs::vec_as_names(names(dots), repair = .name_repair)

  on <- names(dots)
  cj <- expr(CJ(!!!syms(on), unique = TRUE))

  out <- distinct(data, !!!syms(data$groups), !!!dots)
  if (length(data$groups) == 0) {
    out <- step_subset(out, i = cj, on = on)
  } else {
    on <- call2(".", !!!syms(on))
    out <- step_subset(out, j = expr(.SD[!!cj, on = !!on]))
  }

  out
}

# exported onLoad
expand.data.table <- function(data, ..., .name_repair = "check_unique") {
  data <- lazy_dt(data)
  tidyr::expand(data, ..., .name_repair = .name_repair)
}
